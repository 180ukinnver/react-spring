---
name: useTrail
route: /useTrail
order: 60
---

import DemoGrid from '../examples/components/DemoGrid'
import Demo from '../examples/components/Demo'
import examples from '../examples/components/examples-hooks'

# useTrail

```js
import { useTrail, animated } from 'react-spring'
```

useTrail needs the amount of items you want to trail and the props you want to animate. It returns an array of animated-props, which you can then distribute among your views.

### Either: overwrite values to change the animation

If you re-render the component with changed props, the animation will update.

```jsx
const trail = useTrail(items.length, { opacity: 1, from: { opacity: 0 } })
```

### Or: pass a function that returns values, and update using "set"

You will get a `set(Values)` function back, use it to update the animation. This will not cause the component to render, which can be generally more performant. It also prevents configs from being re-created on every render. Handling updates like this is extremely useful for fast-occurring updates, like event streams, mousemoves, etc.

```jsx
const [trail, set] = useTrail(items.length, () => ({ opacity: 1, from: { opacity: 0 } }))
// ...
set({ opacity: 0 })
```

### Finally: distribute animated props among the view

The return value is an array containing animated props.

```jsx
return trail.map(props => <animated.div style={props} />)
```

## Properties

All properties of the [shared-api](/api) apply.

## Demos

<DemoGrid padding={0}>
  {examples.filter(data => data.tags.includes('useTrail')).map(data => (
    <Demo
      key={data.name}
      {...data}
      import={import('../examples/demos/' + data.name)}
    />
  ))}
</DemoGrid>